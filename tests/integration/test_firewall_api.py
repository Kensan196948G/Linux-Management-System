"""
Firewallモジュール - 統合テスト（20件以上）

APIエンドポイントの統合テスト（sudo_wrapperをモック）
"""

from unittest.mock import AsyncMock, MagicMock, patch

import pytest


# テスト用データ
SAMPLE_RULES_IPTABLES = {
    "status": "success",
    "backend": "iptables",
    "tables": {
        "filter": {
            "chains": {"INPUT": "ACCEPT", "FORWARD": "DROP", "OUTPUT": "ACCEPT"},
            "rules": [
                "-A INPUT -i lo -j ACCEPT",
                "-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT",
                "-A INPUT -p tcp --dport 22 -j ACCEPT",
                "-A INPUT -j DROP",
            ],
        }
    },
    "raw_lines": [
        "# Generated by iptables-save",
        "*filter",
        ":INPUT ACCEPT [0:0]",
        ":FORWARD DROP [0:0]",
        ":OUTPUT ACCEPT [0:0]",
        "-A INPUT -i lo -j ACCEPT",
        "COMMIT",
    ],
    "timestamp": "2026-01-01T00:00:00Z",
}

SAMPLE_RULES_UFW = {
    "status": "success",
    "backend": "ufw",
    "raw": "Status: active\n\nTo                         Action      From\n--                         ------      ----\n22/tcp                     ALLOW IN    Anywhere\n80/tcp                     ALLOW IN    Anywhere\n",
    "timestamp": "2026-01-01T00:00:00Z",
}

SAMPLE_POLICY_RESPONSE = {
    "status": "success",
    "backend": "iptables",
    "chains": [
        {"chain": "INPUT", "policy": "ACCEPT", "table": "filter", "rules": []},
        {"chain": "FORWARD", "policy": "DROP", "table": "filter", "rules": []},
        {"chain": "OUTPUT", "policy": "ACCEPT", "table": "filter", "rules": []},
    ],
    "timestamp": "2026-01-01T00:00:00Z",
}

SAMPLE_STATUS_RESPONSE = {
    "status": "success",
    "ufw_active": True,
    "firewalld_active": False,
    "iptables_available": True,
    "nftables_available": False,
    "available_backends": ["ufw", "iptables"],
    "timestamp": "2026-01-01T00:00:00Z",
}

SAMPLE_STATUS_NO_FW = {
    "status": "success",
    "ufw_active": False,
    "firewalld_active": False,
    "iptables_available": False,
    "nftables_available": False,
    "available_backends": [],
    "timestamp": "2026-01-01T00:00:00Z",
}


@pytest.fixture
def client():
    from backend.api.main import app
    from fastapi.testclient import TestClient

    return TestClient(app)


@pytest.fixture
def admin_token(client):
    resp = client.post(
        "/api/auth/login",
        json={"email": "admin@example.com", "password": "admin123"},
    )
    assert resp.status_code == 200
    return resp.json()["access_token"]


@pytest.fixture
def viewer_token(client):
    resp = client.post(
        "/api/auth/login",
        json={"email": "viewer@example.com", "password": "viewer123"},
    )
    assert resp.status_code == 200
    return resp.json()["access_token"]


@pytest.fixture
def auth_headers(admin_token):
    return {"Authorization": f"Bearer {admin_token}"}


@pytest.fixture
def viewer_headers(viewer_token):
    return {"Authorization": f"Bearer {viewer_token}"}


# ===========================================================
# GET /api/firewall/rules
# ===========================================================


class TestFirewallRules:
    """ファイアウォールルール取得テスト"""

    def test_rules_success_iptables(self, client, auth_headers):
        """iptablesバックエンドでルール取得成功"""
        with patch(
            "backend.api.routes.firewall.sudo_wrapper.get_firewall_rules",
            return_value=SAMPLE_RULES_IPTABLES,
        ):
            resp = client.get("/api/firewall/rules", headers=auth_headers)
        assert resp.status_code == 200
        data = resp.json()
        assert data["status"] == "success"
        assert data["backend"] == "iptables"
        assert "tables" in data

    def test_rules_success_ufw(self, client, auth_headers):
        """UFWバックエンドでルール取得成功"""
        with patch(
            "backend.api.routes.firewall.sudo_wrapper.get_firewall_rules",
            return_value=SAMPLE_RULES_UFW,
        ):
            resp = client.get("/api/firewall/rules", headers=auth_headers)
        assert resp.status_code == 200
        data = resp.json()
        assert data["status"] == "success"
        assert data["backend"] == "ufw"

    def test_rules_no_auth(self, client):
        """認証なしで401エラー"""
        resp = client.get("/api/firewall/rules")
        assert resp.status_code == 403

    def test_rules_viewer_allowed(self, client, viewer_headers):
        """Viewerロールはread:firewallを持つ"""
        with patch(
            "backend.api.routes.firewall.sudo_wrapper.get_firewall_rules",
            return_value=SAMPLE_RULES_IPTABLES,
        ):
            resp = client.get("/api/firewall/rules", headers=viewer_headers)
        assert resp.status_code == 200

    def test_rules_has_filter_table(self, client, auth_headers):
        """filterテーブルが含まれる"""
        with patch(
            "backend.api.routes.firewall.sudo_wrapper.get_firewall_rules",
            return_value=SAMPLE_RULES_IPTABLES,
        ):
            resp = client.get("/api/firewall/rules", headers=auth_headers)
        assert resp.status_code == 200
        data = resp.json()
        assert "filter" in data["tables"]

    def test_rules_filter_table_has_chains(self, client, auth_headers):
        """filterテーブルにchainsが含まれる"""
        with patch(
            "backend.api.routes.firewall.sudo_wrapper.get_firewall_rules",
            return_value=SAMPLE_RULES_IPTABLES,
        ):
            resp = client.get("/api/firewall/rules", headers=auth_headers)
        data = resp.json()
        chains = data["tables"]["filter"]["chains"]
        assert "INPUT" in chains
        assert "FORWARD" in chains

    def test_rules_timestamp_present(self, client, auth_headers):
        """timestampフィールドが存在する"""
        with patch(
            "backend.api.routes.firewall.sudo_wrapper.get_firewall_rules",
            return_value=SAMPLE_RULES_IPTABLES,
        ):
            resp = client.get("/api/firewall/rules", headers=auth_headers)
        assert "timestamp" in resp.json()

    def test_rules_wrapper_error_returns_503(self, client, auth_headers):
        """ラッパーエラー時に503を返す"""
        from backend.core.sudo_wrapper import SudoWrapperError

        with patch(
            "backend.api.routes.firewall.sudo_wrapper.get_firewall_rules",
            side_effect=SudoWrapperError("wrapper failed"),
        ):
            resp = client.get("/api/firewall/rules", headers=auth_headers)
        assert resp.status_code == 503


# ===========================================================
# GET /api/firewall/policy
# ===========================================================


class TestFirewallPolicy:
    """ファイアウォールポリシー取得テスト"""

    def test_policy_success(self, client, auth_headers):
        """ポリシー取得成功"""
        with patch(
            "backend.api.routes.firewall.sudo_wrapper.get_firewall_policy",
            return_value=SAMPLE_POLICY_RESPONSE,
        ):
            resp = client.get("/api/firewall/policy", headers=auth_headers)
        assert resp.status_code == 200
        data = resp.json()
        assert data["status"] == "success"
        assert isinstance(data["chains"], list)

    def test_policy_chain_fields(self, client, auth_headers):
        """チェーンにchain/policy/tableフィールドが存在"""
        with patch(
            "backend.api.routes.firewall.sudo_wrapper.get_firewall_policy",
            return_value=SAMPLE_POLICY_RESPONSE,
        ):
            resp = client.get("/api/firewall/policy", headers=auth_headers)
        data = resp.json()
        chain = data["chains"][0]
        assert "chain" in chain
        assert "policy" in chain

    def test_policy_no_auth(self, client):
        """認証なしで401"""
        resp = client.get("/api/firewall/policy")
        assert resp.status_code == 403

    def test_policy_viewer_allowed(self, client, viewer_headers):
        """Viewerはpolicy取得可能"""
        with patch(
            "backend.api.routes.firewall.sudo_wrapper.get_firewall_policy",
            return_value=SAMPLE_POLICY_RESPONSE,
        ):
            resp = client.get("/api/firewall/policy", headers=viewer_headers)
        assert resp.status_code == 200

    def test_policy_forward_drop(self, client, auth_headers):
        """FORWARDチェーンはDROPポリシー"""
        with patch(
            "backend.api.routes.firewall.sudo_wrapper.get_firewall_policy",
            return_value=SAMPLE_POLICY_RESPONSE,
        ):
            resp = client.get("/api/firewall/policy", headers=auth_headers)
        data = resp.json()
        forward = next((c for c in data["chains"] if c["chain"] == "FORWARD"), None)
        assert forward is not None
        assert forward["policy"] == "DROP"

    def test_policy_wrapper_error_returns_503(self, client, auth_headers):
        """ラッパーエラー時に503"""
        from backend.core.sudo_wrapper import SudoWrapperError

        with patch(
            "backend.api.routes.firewall.sudo_wrapper.get_firewall_policy",
            side_effect=SudoWrapperError("error"),
        ):
            resp = client.get("/api/firewall/policy", headers=auth_headers)
        assert resp.status_code == 503


# ===========================================================
# GET /api/firewall/status
# ===========================================================


class TestFirewallStatus:
    """ファイアウォール全体状態テスト"""

    def test_status_success(self, client, auth_headers):
        """状態取得成功"""
        with patch(
            "backend.api.routes.firewall.sudo_wrapper.get_firewall_status",
            return_value=SAMPLE_STATUS_RESPONSE,
        ):
            resp = client.get("/api/firewall/status", headers=auth_headers)
        assert resp.status_code == 200
        data = resp.json()
        assert data["status"] == "success"

    def test_status_fields_present(self, client, auth_headers):
        """必須フィールドが存在する"""
        with patch(
            "backend.api.routes.firewall.sudo_wrapper.get_firewall_status",
            return_value=SAMPLE_STATUS_RESPONSE,
        ):
            resp = client.get("/api/firewall/status", headers=auth_headers)
        data = resp.json()
        assert "ufw_active" in data
        assert "iptables_available" in data
        assert "available_backends" in data

    def test_status_ufw_active(self, client, auth_headers):
        """ufw_activeがTrueの場合"""
        with patch(
            "backend.api.routes.firewall.sudo_wrapper.get_firewall_status",
            return_value=SAMPLE_STATUS_RESPONSE,
        ):
            resp = client.get("/api/firewall/status", headers=auth_headers)
        assert resp.json()["ufw_active"] is True

    def test_status_no_firewall(self, client, auth_headers):
        """ファイアウォールなしの環境"""
        with patch(
            "backend.api.routes.firewall.sudo_wrapper.get_firewall_status",
            return_value=SAMPLE_STATUS_NO_FW,
        ):
            resp = client.get("/api/firewall/status", headers=auth_headers)
        assert resp.status_code == 200
        data = resp.json()
        assert data["ufw_active"] is False
        assert data["iptables_available"] is False
        assert data["available_backends"] == []

    def test_status_no_auth(self, client):
        """認証なしで401"""
        resp = client.get("/api/firewall/status")
        assert resp.status_code == 403

    def test_status_viewer_allowed(self, client, viewer_headers):
        """Viewerはstatus取得可能"""
        with patch(
            "backend.api.routes.firewall.sudo_wrapper.get_firewall_status",
            return_value=SAMPLE_STATUS_RESPONSE,
        ):
            resp = client.get("/api/firewall/status", headers=viewer_headers)
        assert resp.status_code == 200

    def test_status_wrapper_error_returns_503(self, client, auth_headers):
        """ラッパーエラー時に503"""
        from backend.core.sudo_wrapper import SudoWrapperError

        with patch(
            "backend.api.routes.firewall.sudo_wrapper.get_firewall_status",
            side_effect=SudoWrapperError("error"),
        ):
            resp = client.get("/api/firewall/status", headers=auth_headers)
        assert resp.status_code == 503

    def test_status_timestamp_present(self, client, auth_headers):
        """timestampフィールドが存在"""
        with patch(
            "backend.api.routes.firewall.sudo_wrapper.get_firewall_status",
            return_value=SAMPLE_STATUS_RESPONSE,
        ):
            resp = client.get("/api/firewall/status", headers=auth_headers)
        assert "timestamp" in resp.json()


# ===========================================================
# POST /api/firewall/rules  (write + approval)
# ===========================================================

class TestFirewallWriteOperations:
    """Firewall 書き込み操作テスト（承認フロー・カバレッジ向上）"""

    def test_create_rule_success(self, client, auth_headers):
        """ルール追加リクエストが 202 accepted で承認待ちになる"""
        with patch(
            "backend.api.routes.firewall.approval_service.create_request",
            new_callable=AsyncMock,
            return_value={"request_id": "req-001", "status": "pending"},
        ):
            resp = client.post(
                "/api/firewall/rules",
                json={"action": "allow", "port": 8080, "protocol": "tcp", "reason": "テスト"},
                headers=auth_headers,
            )
        assert resp.status_code == 202
        data = resp.json()
        assert data["status"] == "pending_approval"
        assert "request_id" in data

    def test_create_rule_deny_action(self, client, auth_headers):
        """deny ルール追加も承認フロー経由で 202"""
        with patch(
            "backend.api.routes.firewall.approval_service.create_request",
            new_callable=AsyncMock,
            return_value={"request_id": "req-002", "status": "pending"},
        ):
            resp = client.post(
                "/api/firewall/rules",
                json={"action": "deny", "port": 23, "protocol": "tcp", "reason": "Telnet 禁止"},
                headers=auth_headers,
            )
        assert resp.status_code == 202

    def test_create_rule_forbidden_viewer(self, client, viewer_token):
        """viewer ロールはルール追加不可"""
        resp = client.post(
            "/api/firewall/rules",
            json={"action": "allow", "port": 80, "protocol": "tcp", "reason": "テスト"},
            headers={"Authorization": f"Bearer {viewer_token}"},
        )
        assert resp.status_code == 403

    def test_create_rule_invalid_port(self, client, auth_headers):
        """無効なポート番号は拒否"""
        resp = client.post(
            "/api/firewall/rules",
            json={"action": "allow", "port": 99999, "protocol": "tcp", "reason": "テスト"},
            headers=auth_headers,
        )
        assert resp.status_code == 422

    def test_create_rule_no_auth(self, client):
        """未認証は拒否"""
        resp = client.post(
            "/api/firewall/rules",
            json={"action": "allow", "port": 80, "protocol": "tcp", "reason": "テスト"},
        )
        assert resp.status_code in (401, 403)

    def test_create_rule_exception_handling(self, client, auth_headers):
        """approval_service 例外で 500"""
        with patch(
            "backend.api.routes.firewall.approval_service.create_request",
            new_callable=AsyncMock,
            side_effect=Exception("unexpected error"),
        ):
            resp = client.post(
                "/api/firewall/rules",
                json={"action": "allow", "port": 80, "protocol": "tcp", "reason": "テスト"},
                headers=auth_headers,
            )
        assert resp.status_code == 500

    def test_delete_rule_success(self, client, auth_headers):
        """ルール削除リクエストが 202 accepted で承認待ちになる"""
        with patch(
            "backend.api.routes.firewall.approval_service.create_request",
            new_callable=AsyncMock,
            return_value={"request_id": "req-003", "status": "pending"},
        ):
            resp = client.delete(
                "/api/firewall/rules/1",
                headers=auth_headers,
            )
        assert resp.status_code == 202
        data = resp.json()
        assert data["status"] == "pending_approval"

    def test_delete_rule_invalid_num(self, client, auth_headers):
        """無効なルール番号は 422"""
        resp = client.delete(
            "/api/firewall/rules/9999",
            headers=auth_headers,
        )
        assert resp.status_code == 422

    def test_delete_rule_forbidden_viewer(self, client, viewer_token):
        """viewer ロールはルール削除不可"""
        resp = client.delete(
            "/api/firewall/rules/1",
            headers={"Authorization": f"Bearer {viewer_token}"},
        )
        assert resp.status_code == 403

    def test_delete_rule_no_auth(self, client):
        """未認証は拒否"""
        resp = client.delete("/api/firewall/rules/1")
        assert resp.status_code in (401, 403)

    def test_delete_rule_exception_handling(self, client, auth_headers):
        """approval_service 例外で 500"""
        with patch(
            "backend.api.routes.firewall.approval_service.create_request",
            new_callable=AsyncMock,
            side_effect=Exception("unexpected error"),
        ):
            resp = client.delete(
                "/api/firewall/rules/1",
                headers=auth_headers,
            )
        assert resp.status_code == 500

    def test_rules_exception_handling(self, client, auth_headers):
        """GET /rules で予期しない例外は 500"""
        with patch(
            "backend.api.routes.firewall.sudo_wrapper.get_firewall_rules",
            side_effect=Exception("unexpected"),
        ):
            resp = client.get("/api/firewall/rules", headers=auth_headers)
        assert resp.status_code == 500
